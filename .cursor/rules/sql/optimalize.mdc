---
description: SQL query optimization, index design, schema standards, and advanced SQL patterns for MySQL/MariaDB.
alwaysApply: true
---

## Query Analysis
- Run `EXPLAIN` on every new or modified query.
- Flag: type `ALL`, high `rows`, `Using filesort`, `Using temporary`.
- Use `EXPLAIN ANALYZE` for actual vs estimated row counts.
- Check slow query log — prioritize frequent or longest-running queries.
- Apply one optimization at a time; measure before and after.

## Query Optimization
- SARGable WHERE clauses only — no functions on indexed columns (`DATE(col)`, `LOWER(col)`, `col + 1`).
- Prefer ranges: `col BETWEEN ? AND ?` instead of `DATE(col) = ?`.
- Seek pagination (`WHERE id > ? LIMIT ?`) instead of OFFSET for large datasets.
- Push filtering, sorting, and aggregation into SQL — never in application code.
- Never `SELECT *` — fetch only needed columns.
- Prepared statements with bound parameters; never concatenate user input into SQL.
- Avoid negative conditions (`<>`, `!=`, `NOT IN`, `NOT LIKE`) — they prevent index usage.
- Prefer `EXISTS` over `COUNT(*)` for existence checks — stops at first match.
- Use set-based operations over row-by-row processing.

```sql
-- Bad — function on indexed column
SELECT * FROM users WHERE DATE(created_at) = '2025-01-01';

-- Good — SARGable range
SELECT * FROM users WHERE created_at BETWEEN '2025-01-01 00:00:00' AND '2025-01-01 23:59:59';

-- Bad — OFFSET pagination on large table
SELECT * FROM users ORDER BY id LIMIT 25 OFFSET 25000;

-- Good — seek pagination
SELECT * FROM users WHERE id > 25000 ORDER BY id LIMIT 25;

-- Bad — COUNT for existence
SELECT * FROM users WHERE (SELECT COUNT(*) FROM orders WHERE orders.user_id = users.id) > 0;

-- Good — EXISTS
SELECT * FROM users WHERE EXISTS (SELECT 1 FROM orders WHERE orders.user_id = users.id);
```

## Index Design
- Index columns used in `WHERE`, `JOIN`, `ORDER BY`, `GROUP BY`.
- Composite index order must match query filter/sort (left-to-right rule).
- Use covering indexes when a query can be satisfied from the index alone.
- Index JOIN columns on both sides.
- Aim for 3–5 well-chosen indexes per table.
- Drop unused or redundant indexes when changing schema.
- Prefer parallel index creation on large tables.
- Do not create indexes on low-cardinality columns alone.
- Do not keep single-column indexes when a composite index already covers them.
- Nullable columns should appear last in composite indexes.

```sql
-- Query filters by (user_id, status) and sorts by created_at
-- Composite index must match this order:
ALTER TABLE orders ADD INDEX idx_user_status_created (user_id, status, created_at);
```

## Transactions and Locking
- Keep transactions short — no external calls or heavy logic inside.
- Batch related writes in a single transaction.
- Use appropriate isolation levels for the use case.
- Deadlock-prone operations must include retry logic.
- Reduce lock contention via batching and suitable isolation levels.
- Use `SHOW ENGINE INNODB STATUS` to diagnose lock waits.

## Schema Design
- Primary keys on every table.
- Fitting data types: `INT`, `DECIMAL`, `VARCHAR(n)`, `TIMESTAMP`.
- InnoDB engine.
- `lower_case_snake_case` naming.
- Normalized unless denormalization is justified by read performance.
- Partition large tables by range where beneficial.
- Non-blocking index creation on large tables where supported.

## Advanced SQL Patterns
- Use CTEs for complex multi-step queries — prefer over nested subqueries.
- Use window functions (`ROW_NUMBER`, `RANK`, `LAG`, `LEAD`) for analytics and ranking without self-joins.
- Use recursive CTEs for hierarchical data (categories, org trees).

```sql
-- CTE for multi-step logic
WITH active_users AS (
    SELECT id, name, email
    FROM users
    WHERE status = 'active'
)
SELECT au.name, COUNT(o.id) AS order_count
FROM active_users au
JOIN orders o ON o.user_id = au.id
GROUP BY au.id, au.name;

-- Window function for ranking
SELECT
    user_id,
    amount,
    ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY amount DESC) AS rank_num
FROM orders;

-- Recursive CTE for hierarchical data
WITH RECURSIVE category_tree AS (
    SELECT id, name, parent_id, 0 AS depth
    FROM categories
    WHERE parent_id IS NULL
    UNION ALL
    SELECT c.id, c.name, c.parent_id, ct.depth + 1
    FROM categories c
    JOIN category_tree ct ON c.parent_id = ct.id
)
SELECT * FROM category_tree;
```

## Caching at DB Level
- Use query result caching for repeated expensive queries with same parameters.
- Invalidate cache on relevant data changes.
- Mitigate cache stampede (locking, stale-while-revalidate).
